 #+TITLE:     Concetti di Programmazione in Java
#+AUTHOR: 
#+EMAIL:     
#+DATE:      
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  it
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

#+startup: beamer nolatexpreview
#+LaTeX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [10pt, presentation, aspectratio=169]
#+LATEX_HEADER:\beamertemplatenavigationsymbolsempty
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \geometry{text margin left=0.15in, text margin right=0.15in}


#+LATEX_HEADER: \newcommand{\figures}{./img}
#+LATEX_HEADER:\DeclareMathOperator*{\argmax}{\arg\!\max}
#+LATEX_HEADER: \author[A. Caliò]{Antonio Caliò}
#+BEAMER_HEADER:\institute{Cooperativa Servizi \& Formazione\\Catanzaro (CZ)}
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Presentat‌​‌​ion agenda}\tableofcontents[currentsection]\end{frame}}

#+BEAMER_FRAME_LEVEL: 2
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) n%10BEAMER_extra(Extra)

 #+latex_header: \addtobeamertemplate{navigation symbols}{}{\usebeamerfont{footline}   \usebeamercolor[fg]{footline}\hspace{1em} \insertframenumber/\inserttotalframenumber}


 # #+latex_header:\setbeamertemplate{footline}{ \hbox{  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.7ex,dp=1ex,center]{author in head/foot}	\insertshortauthor  \end{beamercolorbox} \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.6ex,dp=1ex,center]{author in head/foot}	{\usebeamercolor[fg]{footline} Corso Developer 2020/2021}  \end{beamercolorbox}  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.6ex,dp=1ex,rightskip=.15cm,right]{author in head/foot}    \usebeamerfont{section in foot} \insertframenumber/\inserttotalframenumber  \end{beamercolorbox}}  \vskip0pt}

#+latex_header: \usepackage{algorithm,algorithmic}
#+latex_header: \usepackage{amsmath,amssymb,amsfonts}
#+latex_header: \usepackage{listings}
#+latex_header: \lstset{basicstyle=\scriptsize\ttfamily}


*  Value vs  Reference


** Concetti Chiave
***                                                                 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Chiamata vs Chiamante
  - La funzione da cui parte la chiamata è detta: *Chiamante* (Caller) 
  - L'altra funzione richiamata è detta: *Chiamata* (Callee)
- Actual vs Formal Parameters
  - *Actual Parameters*:  valori concretamente passati in input
    durante la chiamata
  - *Formal Parameters*: valori richiesti nella definizione della
    funzione

***                                                         :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+ATTR_LATEX: :scale .4
[[file:img/function.png]]


** Passaggio per Valore
*** Left                                                            :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
  - Si esegue una copia dei parametri passati in input
    - La funziona chiamante e quella chiamata hanno due set di variabili
      indipendenti aventi lo stesso valore
    - Le modifiche a tali variabili eseguite dalla funzione *chiamata* non sono visibili
       dalla funzione *chiamante*
*** Right                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_export latex
\begin{figure}
\includegraphics[scale=0.3]{\figures/value.png}
\end{figure}
#+end_export

** Passaggio per Riferimento (o per Indirizzo)
*** Left                                                            :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
  - Il chiamante passa il riferimento i.e., indirizzo di memoria
    - Se all'interno della funzione *chiamata* si eseguono delle
      modifiche agli /actual parameters/ passati in input:
      - Le modifiche saranno visibili anche dall'esterno della
        funzione *chiamata*
*** Right                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
#+begin_export latex
\begin{figure}
\includegraphics[scale=0.3]{\figures/ref.png}
\end{figure}
#+end_export

** Cosa succede in Java?
- *In Java i parametri sono sempre passati per valore!*
- Tuttavia dobbiamo fare attenzione quando lavoriamo con gli oggetti:
  - Se un metodo richiede in input un oggetto (quindi un tipo non
    primitivo):
    - Java eseguirà una copia del *riferimento* a quel determinato oggetto
  - Concretamente, gli oggetti sono passati per riferimento

** Cosa succede in Java?
[[file:img/javaob.png]]

** Quiz
\scriptsize
#+begin_src java  :results output :exports both
public class App {
	public static void main(String... doYourBest) {
    	    Simpson simpson = new Simpson();
    	    transformIntoHomer(simpson);
    	    System.out.println(simpson.name);
	}
	static void transformIntoHomer(Simpson simpson) {
    	    simpson.name = "Homer";
	}
}
class Simpson {
	String name;
}
#+end_src
#+RESULTS:

** Quiz
\scriptsize
#+begin_src java
public class PrimitiveByValueExample {

	public static void main(String... primitiveByValue) {
    	    int homerAge = 30;
    	    changeHomerAge(homerAge);
    	    System.out.println(homerAge);
	}

	static void changeHomerAge(int homerAge) {
    	    homerAge = 35;
	}
}
#+end_src

** Oggetti Immutabili

***                                                                 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:

- Oggetti  contrassegnati come *final*
- Una volta inizializzati, il loro valore non può essere modificato
  - Mantengono lo stesso valore per tutta l'esecuzione del programma
- Java ha molte classi immutabili:
  - Integer, Double, Float, Long, Boolean, BigDecimal, String

***                                                                 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\scriptsize
#+begin_src  java
public class StringValueChange {
	public static void main(String[] args) {
    	    String name = "";
    	    changeToHomer(name);
    	    System.out.println(name);
	}

	static void changeToHomer(String name) {
    	    name = "Homer";
	}
}
#+end_src

** Test
\scriptsize

***                                                                 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src  java
     public class DragonWarriorReferenceChallenger {
       public static void main(String... doYourBest) {
         StringBuilder wProf =
             new StringBuilder("Dragon ");
         String wWeap = "Sword ";
         changeWarriorClass(wProf, wWeap);
         System.out.println("Warrior=" +wProf +
                            " Weapon=" + wWeap);
       }
       static void changeWarriorClass(StringBuilder prof,
                                      String weap) {
         prof.append("Knight");
         weap = "Dragon " + weap;

         weap = null;
         prof = null;
       }
     }
#+end_src

***                                                                 :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
1. Warrior=null Weapon=null
2. Warrior=Dragon Weapon=Dragon
3. Warrior=Dragon Knight Weapon=Dragon Sword
4.  Warrior=Dragon Knight Weapon=Sword


* Ereditarietà, dynamic binding, polimorfismo


** Nozioni Preliminari
- Progettare una nuova classe per estensione di una classe esistente,
 dunque per differenza.
  - permette di concentrarsi sulle novità introdotte dalla
    nuova classe
  - favorisce produttività del programmatore




** Una Classe ContoBancario: Specifiche
- Di seguito si considera una classe ContoBancario che definisce le
  usuali operazioni di deposito e prelievo
- Un conto è identificato da un numero espresso mediante una String, e si caratterizza per il suo bilancio
- Non è permesso al bilancio di andare “in rosso”
  - ossia un prelevamento oltre il valore del bilancio non viene consentito
    - A questo scopo il metodo preleva() ritorna un valore boolean che
      è true se l’operazione si conclude con successo, false altrimenti
- Metodi  accessori permettono di conoscere il numero di conto e il
  valore corrente del bilancio.


** Una classe ContoBancario: Implementazione
\scriptsize
#+begin_src java  :results output :exports both
import java.io.*;
public class ContoBancario{
  private String numero;
  private double bilancio=0;
  public ContoBancario( String numero ){...}//primo costruttore
  public ContoBancario( String numero, double bilancio){..{}//secondo costruttore

public void deposita( double quanto ){ ..}

public boolean preleva( double quanto ) { .. }

public double saldo(){ return bilancio;}
public String conto(){ return numero; }
public String toString(){
   return String.format( "conto=%s bilancio=E %1.2f", numero, bilancio );
  }//toString
}//ContoBancario

#+end_src
#+RESULTS:

** Un Secondo Conto Bancario, con Fido: Specifiche

- ContoBancario va bene per i clienti “ordinari"
- La banca dispone di un altro tipo di conto _ContoConFido_ riservato a clientela selezionata
  - ammette l’andata in rosso controllata da un fido. 
- ContoConFido mantiene molte caratteristiche di ContoBancario ma in
  più introduce delle differenze:
  - Il bilancio può andare in rosso
** Un Secondo Conto Bancario, con Fido: Implementazione
\scriptsize
#+begin_src  java
import java.io.*;
public class ContoConFido extends ContoBancario {
  private double fido=1000; //default
  public ContoConFido( String numero ) { super( numero );}
  public ContoConFido( String numero, double bilancio ){super( numero, bilancio ); }
  public ContoConFido( String numero, double bilancio, doublé fido ){
    super( numero, bilancio ); 
    this.fido=fido;
  }
  public boolean preleva( doublé quanto ){ super.preleva(quanto)... }
  public double fido(){ ...}
public void nuovoFido( double fido ){...}
public String toString(){ ... }

}//ContoConFido
#+end_src

** Il Pronome Super
- Serve a riferirsi alla super classe
  - ad esempio per invocare esplicitamente un costruttore della super classe
    - si delega parte del processo di costruzione.
    - se è usato per questi scopi, super,  deve essere la prima
      istruzione del costruttore.
- Si noti che:
  - essendo private il campo bilancio di ContoBancario: ogni sua
   modifica va ottenuta mediante i metodi di ContoBancario

** Modifiche alla classe ContoConFido
- Modificare la classe ContoConFido di modo che:
  - Si tenga traccia dell'ammontare scoperto da parte del correntista

*** Esempio                                                :B_exampleblock:
:PROPERTIES:
:BEAMER_env: exampleblock
:END:
- Il correntista possiede 100$ e cerca di prelevare 200$:
  - L'ammontare scoperto è pari a 100$


** Relazione di ereditarietà
:PROPERTIES:
:BEAMER_opt: t
:END:
\scriptsize
*** Columns                                                     :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:BEAMER_opt: t
:END:
****                                          :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- ContoConFido è-un (is-a) ContoBancario, ma un pò più specializzato.
- ContoConFido è una sottoclasse (o classe derivata)
- ContoBancario una super-classe (o classe base).
- La relazione di ereditarietà da ContoConFido a ContoBancario è una relazione di generalizzazione
- La relazione di ereditarietà è ben definita se un oggetto della
  classe derivata può sempre sostituire un oggetto della classe base
  - *principio di sostituibilità dei tipi*
- *Tuttavia: un conto bancario non è un conto con fido!!!!*

****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- La parentela ci permette di scrivere:
\tiny
#+begin_src  java

ContoBancario cb=new ContoBancario(...);
ContoConFido ce=new ContoConFido(...);
cb=ce; //assegnazione dal particolare al generale OK

#+end_src


#+begin_export latex
\begin{figure}
\includegraphics[scale=0.5]{\figures/ere.png}
\end{figure}
#+end_export

** Assegnazione tra oggetti come proiezione
#+begin_export latex
\begin{figure}
\includegraphics[scale=0.4]{\figures/pro.png}
\end{figure}
#+end_export
\scriptsize
- L’assegnazione da particolare a generale corrisponde, ad es., alla proiezione di un punto dello spazio
cartesiano (con coordinate x, y e z) sul piano X-Y (la coordinata z è
ignorata). 
- Nella situazione effettiva di Java, a seguito dell’assegnazione   =cb=ce=, =cb= punta all’oggetto composito riferito da =ce=
- Tuttavia, =cb= lo vede con gli “occhiali” imposti dalla sua classe di appartenenza ContoBancario.
- Pertanto i campi fido e scoperto, anche se effettivamente presenti nell’oggetto puntato da =cb=, sono ignorati.

** Tipo statico e dinamico di un oggetto
\scriptsize
#+begin_src  java

ContoBancario cb=new ContoBancario(...);
ContoConFido ce=new ContoConFido(...);
cb=ce; //assegnazione dal particolare al generale OK

#+end_src
\vskip -.5cm
\small
- Dopo l'assegnazione =cb=ce=, ogni uso di =preleva()= si riferisce alla sotto classe
  - =cb= ha tipo statico (legato cioè alla dichiarazione) =ContoBancario=
  - =cb= ha tipo dinamico (guadagnato in seguito all'assegnazione)
   =ContoConFido=
- Il tipo statico dice cosa si può fare su =cb=
- Il tipo dinamico dice quale particolare metodo va in esecuzione:
  - se uno della super classe o uno della sotto classe.
- Prima dell’assegnazione, =cb.preleva(...)=  si riferisce al metodo della super classe.
- Dopo l’assegnazione, =cb.preleva(...)= invoca di fatto la versione
  di preleva di =ContoConFido=.

**  Assegnazione dal generale al particolare ?
\scriptsize
- Non si può assegnare un oggetto da generale al particolare,
  es. =ce=cb=
  - =cb= non ha campi e valori corrispondenti ai campi particolari
    introdotti dalla classe conto con fido
  - non ha senso proiettare un punto dal piano cartesiano X-Y nello spazio, dal momento che non è definita la coordinata z

- Tuttavia, se cb ha tipo dinamico =ContoConFido=, si può di fatto
  cambiare punto di vista ("paio di occhiali”) su =cb= in modo da
  vederlo come =ContoConFido= e quindi accedere a tutte le
  funzionalità di =ContoConFido=
  #+begin_src  java

    if( cb instanceof ContoConFido )(
    ce=(ContoConFido)cb; //casting
    ce.nuovoFido(5000);
    }
#+end_src


- Su una variabile =cb= di classe (tipo statico) =ContoBancario=
  possono essere richieste sempre e solo le funzionalità della classe cui appartiene
- Se =cb= ha tipo dinamico =ContoConFido=, invocando un metodo ridefinito in =ContoConFido= come preleva/deposita, di fatto si esegue la versione del metodo di =ContoConFido=
- Se =cb= ha tipo dinamico =ContoConFido=, controllabile con
  =instanceof= è allora possibile cambiare il punto di vista su =cb= (/casting/)

** Dynamic binding e polimorfismo

- Il dynamic binding (collegamento dinamico) si riferisce alla proprietà che invocando un metodo su un oggetto
  come =cb=, dinamicamente possa essere eseguita la versione del metodo
 definita in:  =ContoBancario= oppure =ContoConFido=
- Il termine polimorfismo significa "più forme” ed esprime la
  proprietà che un oggetto possa appartenere a più tipi
  - con =cb=ce=, l’oggetto =cb= acquisisce un altro tipo (diventa polimorfo)
  -  Il polimorfismo di cb si può verificare come segue
#+begin_src  java
if(cb instanceof ContoBancario ) è TRUE
if(cb instanceof ContoConFido ) è TRUE
#+end_src

- dynamic binding e polimorfismo sono le due facce di una stessa
  medaglia:
  - Il polimorfismo è la causa del dynamic binding

** Ereditarietà e ridefinizione dei metodi
 - =ContoConFido= ridefinisce i metodi =deposita= e =preleva= già
   presenti nella =super=  classe =ContoBancario=
   - occorre normalmente rispettare la sua intestazione (signature)
   - se cambia qualcosa nell’intestazione (nome del metodo, tipi dei
     parametri):    /overloading/ anziché di ridefinizione (/overriding/).
 - Perchè funzioni correttamente il dynamic binding/polimorfismo, è necessario osservare l’esatta intestazione
#+begin_src  java
@Override // ANNOTAZIONE FACOLTATIVA!!!!
public boolean preleva( doublé quanto ){...}  
#+end_src
- L'annotazione permette al compilatore di controllare ed
  eventualmente segnalare problemi

** Ereditarietà singola
- In Java ogni classe può essere erede di una sola classe (ereditarietà singola).
- Tutto ciò permette la costruzione di gerarchie di classi secondo una struttura ad albero
  - Ogni classe ha solo un genitore
- Avere una gerarchia accresce la possibilità di polimorfismo

*** Columns                                                     :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:BEAMER_opt: t
:END:
**** Esempio                                               :B_block:BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:BEAMER_env: block
:END:
\scriptsize
- Oggetti di classe E sono anche di classe: B, A
- Ad una variabile di  classe A è possibile assegnare un oggetto di
  qualsiasi sottoclasse: B, C, D, E, F
- Il tipo dinamico di un oggetti di classe A può essere uno qualsiasi
  delle sottoclassi 
****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
#+begin_export latex
\begin{figure}
\includegraphics[scale=0.4]{\figures/tree.png}
\end{figure}
#+end_export

** Ereditarietà vs composizione
- Riflessione sulla relazione di ereditarietà alla luce del principio
  di sostituibilità dei tipi


*** Esempio                                                       :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
  - Un oggetto =Linea= (segmento) è caratterizzato da due punti
    (oggetti di classe =Punto=)
  - *È corretto definire =Linea= come sottoclasse di =Punto=?*
\pause
  - No! Rappresenta una forzatura.
  - Una =Linea= non è un =Punto=, ma è /composta/ (has-a) da punti
  - Pertanto la cosa migliore è definire la classe =Linea= come segue:
 #+begin_src  java
class Linea {
  Punto p1, p2;
}  
#+end_src

** L'antenato Object
- In Java, ogni classe eredita direttamente o indirettamente da =Object= (radice di tutte le gerarchie di classi)
- Quando una classe non specifica la clausola extends, in realtà
  ammette implicitamente la clausola: =extends Object=
- I metodi seguenti ammettono già un’implementazione in =Object= che necessariamente è generica. Essi vanno
di norma ridefiniti per avere un significato “tagliato su misura” delle nuove classi:
• =String toString()= - ritorna lo stato di =this= sotto forma di stringa
- =boolean equals( Object x )=  ritorna true se this ed x sono uguali
  - =Object= definisce l’uguaglianza in modo superficiale: due oggetti
    sono uguali se sono in aliasing, ossia condividono lo stesso riferimento
- =int hashCode()= - ritorna un hash code (numero intero unico) per =this=

** Strutture Dati Eterogenee

- Grazie alla ereditarietà implicita da =Object= possiamo dichiarare
  strutture dati eterogenee come segue:
#+begin_src  java
Object[] v = new Object[10];
#+end_src
- in =v= possiamo memorizzare oggetti appartenenti a qualsiasi classe
- per scoprire il tipo di un oggetto contenuto in =v= possiamo scrivere
#+begin_src  java
if(v[i] isinstanceof String)   ...
#+end_src

** Recap: modificatori di accesso

\scriptsize
- Gli attributi di una classe (campi o metodi) possono avere un modificatore tra
  - =public= se sono esportati a tutti i possibili client
  - =private= se rimangono ad uso esclusivo della classe
  - =protected= se sono esportati solo alle classi eredi
  - (nulla) se devono essere accessibili all’interno dello stesso package (familiarità o amicizia tra classi).

- Attenzione: gli attributi =protected= sono accessibili anche nell’ambito del package di appartenenza.
- Una classe può essere =public= se è esportata per l’uso in altri
  file, non avere il modificatore =public= se il suo uso è ristretto al =package= (eventualmente anonimo) di appartenenza.
- Una classe può essere =final= se non può essere più estesa da classi
  eredi.
  - similmente, un metodo =final= non può essere più ridefinito nelle sottoclassi
- In una ridefinizione di metodo è possibile ampliare il suo
  modificatore ma non restringerlo
- Ad es. nella super classe il metodo potrebbe essere =protected= e
  nella sotto classe =public=, ma non viceversa. 

** Esercizi
\scriptsize
*** ContoBancario                                                 :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- Si implementi la gerarchia di classi =ContoBancario=
- Si implementi una classe =BancaArray= che contenga al suo interno
  una collezione di conti bancari (possono essere di tipo
  =ContoBancario= oppure =ContoConFido=)


*** Contatore                                                     :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
- Si consideri una classe =Contatore= che fornisce l'astrazione di un contatore, ossia una variabile intera che può
essere incrementata/decrementata. 
- La classe dispone di tre costruttori:
\scriptsize
  1. quello di default che inizializza a zero il contatore
  2. quello normale che imposta il valore iniziale del contatore con il valore di un parametro
  3. quello di copia che imposta il contatore dal valore di un altro
     contatore. Per semplicità il campo valore è dichiarato protected
     (esportato cioè alle classi eredi).

- Si implementi una seconda classe =ContatoreModulare= che erediti

     - Un contatore con modulo 10 è un contatore che assume tutti i
       valori da 0-9. Una volta raggiunto il valore 9, ritorna
       nuovamente a 0.



  


* Classi Astratte e Interfaccia

** Una gerarchia di classi per figure geometriche piane
*** Columns                                                     :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:BEAMER_opt: t
:END:

****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.7
:END:
- Si considerano le comuni figure piane:
  - cerchio, quadrato, rombo, trapezio ...
- Si vuole organizzare le figure in modo da facilitarne l’utilizzo nelle applicazioni
  - tutte posseggono almeno una dimensione,
    - il raggio per il cerchio
    - il lato per il quadrato o il rombo
    - la base e l'altezza per un rettangolo
- Per “imparentare" le figure si può concepire una classe base
 =Figura= che poi ogni figura particolare può estendere e specializzare
  - in Figura si può introdurre una dimensione (double) e i metodi che
    certamente hanno senso su tutte le figure.

****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.3
:END:
#+begin_export latex
\begin{figure}
\includegraphics[scale=0.4]{\figures/figuraGer.png}
\end{figure}
#+end_export


** Discussione
- Identificare una gerarchia di classi come quella di cui si sta
  discutendo ha una cruciale importanza
  - Si può introdurre nella classe base (=Figura=) tutti quegli
    elementi (attributi e metodi) comuni a qualunque erede.
    - In questo modo si evitano ridondanze e si garantisce ad ogni
      classe derivata di possedere i “connotati" di appartenenza ad una stessa “famiglia".

- Si rifletta ora che prevedendo una dimensione (cioè un lato) nella
 classe =Figura=,  il suo concreto significato non è chiaro
  - per un cerchio si tratterà del suo raggio
  - per un quadrato del suo lato
  - per un rettangolo la sua base
- Metodi come =perimetro()= ed =area()= previsti in =Figura= non si
  possono dettagliare in quanto manca l’informazione su come interpretare la figura
- Si dice che una classe come Figura è *astratta* (*abstract*) proprio perchè ancora incompleta
  - Spetterà poi alle classi eredi concretizzare tutti quegli aspetti
    previsti in =Figura= ma al momento astratti

** Implementazione classe Figura

#+begin_src  java
      public abstract class Figura {
        private double dimensione;
        public Figura( double dim ){
              if( dim<=0 )
                  throw new IllegalArgumentException();
              this.dimensione=dim;
        }
        protected getDimensione(){ return dimensione;}
        public abstract double perimetro();
        public abstract double area();
    }
#+end_src

** Discussione II

- Una classe astratta come =Figura= non è istanziabile.
  \pause
  - Allora a che ... serve ?
    \pause
  - Serve come base per progettare classi eredi!
- Per definire una classe astratta si deve premettere al nome class la
  keyword  =abstract=
- In una classe astratta uno o più metodi sono di norma astratti.
  - Una classe erede  è concreta se implementa (ne fornisce cioè il corpo) tutti i metodi abstract.
    - Se qualche metodo rimane ancora astratto, anche la classe erede è astratta e spetta ad un ulteriore erede implementare i rimanenti metodi abstract etc.
- Si nota che in una classe astratta possono essere presenti campi dati (es. dimensione) e metodi concreti.
  - Ad esempio =getDimensione()=, utile solo per le classi eredi (esportazione protected), è concreto. 


** Implementazione classe Cerchio
\scriptsize
#+begin_src  java
  public class Cerchio extends Figura{ 
      public Cerchio( double raggio )( super(raggio);}
      public Cerchio( Cerchio c ){ super(c.getDimensione());}
      public double getRaggio(){ return getDimensione();}

      public double perimetro(){ return 2*Math.PI‘ getDimensione(); }//perimetro
      public double area(){
          double r=getDimensione();
          return PI*r;
      }
      public String toString(){
          return “Cerchio: raggio=“+getDimensione();
      }//toString
     public boolean equals(Object other){...}
  }//Cerchio
#+end_src

- Essendo privato il campo dimensione di =Figura=, si è fatto ricorso
  ai metodi =getDimensione()/setDimensione()= per accedervi da dentro =Cerchio=.
- Il metodo =equals()= necessariamente è peculiare di ogni classe
  erede, e per questa ragione non è stato previsto in =Figura=.
  - Similmente per il metodo =toString()=
  - In altre situazioni può essere invece conveniente anticipare nella
    super classe una implementazione dei metodi =equals()=, =hashCode()= e =toString()=
  
** Esercizi
- Si implementi una classe =Rettangolo=
- Si implementi una classe =Utility= che contenga soltanto metodi
  statici. Fornire l'implementazione della seguente funzione:
  - =areaMassima=: riceve in ingresso una collezione di figure e
    restituisce quella con l'area massima.



** Una classe astratta per il problema dell'ordinamento
  
*** Columns                                                     :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:BEAMER_opt: t
:END:

****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
- Di seguito sivaluta la possibilità di risolvere il problema
  dell'ordinamento di un array di oggetti
- Occorre avere  una classe che fornisce un metodo di ordinamento che
  si fonda su un criterio di confronto da specializzare di caso in caso.
  - In fondo, la logica dell’ordinamento è sempre la stessa,
    indipendentemente dalla tipologia degli oggetti
    - Occorre specializzare il concetto di minore/maggiore

****                                                               :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
\scriptsize
#+begin_src java
  public abstract class Sortable{
     protected abstract int compareTo( Sortable x );
     public static void sort( Sortable []v ){
            for( int j=v.length-1; j>0; j - ){
                int iMax=0;
                for( int i=0; i<=j; i++ )
                    if( v[i].compareTo(v[iMax))>0 ) iMax=i;
                //scambia
                Sortable park=v[j];
                v[j]=v[iMax];
                v[iMax]=park;
            }//for
     }//sort
  }//Sortable
#+end_src

- Il metodo =compareTo= deve sostituire:
  - 0 se l'istanza passata in input è uguale a =this=
  - un valore <0 se =this= è minore dell'istanza passata in input
  - un valore >0 se =this= è maggiore dell'istanza passata in input
** Esercizi
- Si definisca una  classe =Intero=, erede di =Sortable=, che
  memorizzi al suo interno il valore di un numero intero, sulla base
  del quale dovrà essere eseguito l'ordinamento
- Testare il funzionamento della nuova classe

  \vspace{1cm}

  - Inglobare la classe =Sortable= nel progetto relative alla class =Razionale=
  - Testare il funzionamento

** Limiti dell'approccio
L’approccio non è applicabile se una classe i cui oggetti si vogliono ordinare, è già legata in una gerarchia di
ereditarietà e dunque non può estendere Sortable. Es. volendo ordinare oggetti di classe Impiegato, si
potrebbe trovare che Impiegato già estende Persona e dunque non può estendere Sortable ... Sarebbe utile
l’ereditarietà multipla cosi che Impiegato potrebbe estendere Persona e Sortable ... Ma Java ammette solo
l’ereditarietà singola.
In più, se si vuole cambiare il metodo di ordinamento, si può progettare una classe erede di Sortable, es.
quickSortable, che lascia astratto compareTo() ma ridefinisce il metodo sort() secondo quickSort. Le classi
eredi che vogliono sfruttare quickSort possono derivare da Sortable ma devono utilizzare il metodo statico di
ordinamento di QuickSortable.
Il concetto di interfaccia
Anche se non è possibile per una classe ereditare simultaneamente da più di una super classe, Java

** COMMENT Il concetto di interfaccia

Il concetto di interfaccia
Anche se non è possibile per una classe ereditare simultaneamente da più di una super classe, Java
introduce un meccanismo per “simulare” l'eredità multipla: le interfacce.
Una classe può estendere una sola classe ma può implementare zero, una o più interfacce.
Un'interfaccia (interface) è una raccolta di intestazioni (segnature) di metodi. In più essa può ammettere
definizioni di attributi costanti e tipi innestati (si veda più avanti nel testo). Le segnature di metodi sono
definizioni astratte pur senza il modificatore abstract. Un’interfaccia, cosi come una classe astratta, non è
istanziabile. Una classe che implementi un'interfaccia deve fornire un’implementazione di tutti i metodi definiti
nell’interfaccia, diversamente la classe è astratta.
In java.lang è definita la seguente interfaccia:
public interface Comparable{
public int compareTo( Object x );
}//Comparable
Per massima generalità, compareTo() lavora su Object. compareTo(x) ritorna <0, ==0, >0 a seconda che
l’oggetto this sia rispettivamente minore, uguale o maggiore di x.


** COMMENT Razionali comparabili
#+begin_src  java
Razionali comparabili
______
__
__
package poo.razionali;
public class Razionale implements Comparable{
//... come prima
public int compareTo( Object x ){
Razionale r=(Razionale)x;
int mcm=(this.denominatore*r.denominatore)/mcd(this.denominatore, r.denominatore);
int n1=(mcm/this.denominatore)‘ this.numeratore;
int n2=(mcm/r.denominatore)*r.numeratore;
if( n1<n2 ) return -1;
ifj n1>n2 ) return 1;
return 0;
}//compareTo
}//Razionale

#+end_src

Dal fatto che Razionale estende (implicitamente) Object, discende che i razionali sono anche di tipo Object.
Dal fatto che Razionale implementa Comparable, deriva che gli oggetti razionali sono anche comparabili,
ossia di tipo Comparable (aumento del polimorfismo). Un array di Comparable è dunque un array di oggetti sui
quali è definito il criterio di confronto.
La classe di utilità Array di poo.util
Array è progettata per fornire alcuni metodi di uso ricorrente sugli array, es. i metodi di ordinamento, ricerca

** COMMENT Digressione: Algoritmi di ordinamento
